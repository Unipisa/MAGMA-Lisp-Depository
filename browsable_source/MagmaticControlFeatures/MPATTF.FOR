      SUBROUTINE MPATTF
C
      IMPLICIT INTEGER(A-Z)
C
C
      INTEGER*2
     * FTYPE,DUE,
     *NREDMO,PILA
     *RRADIX,CXT,KEY,RADIX,KEYM,KEY1,KEY2,TRE,R1,REDEFT,
     * UNO,DUMMY,KEYTEM,NENTPO,CXTT,SNUM,NAPPID,ACXT,
     * AAK,LIB,LIST,R,S,CXTX,PADRE,FIRSTS,FIRSTB
C
      LOGICAL FLAG
C
      COMMON /I1/t10 /LIFE/LIFE (128)
      COMMON /VALUE/ FWQ(4) ,VALUE(1023)
      COMMON / KGBC / KGBC
      COMMON /LISTA/PILA (256) /NREDMO/NREDMO
      COMMON /CONTAP/CONTAP /LASTAP/LASTAP /SCTSON/SCTSON /LISTSC/LISTSC
     */SCTHEA/SCTHEA /LISPXA/LISPXA /ERRORA/ERRORA
      COMMON /REDEFT/REDEFT
      LOGICAL LOOKA P
      COMMON
     */ UNIT / UNIT
C
      COMMON
     */ ABLOCK / V1(3),ABLOCK(1284)
     */ BBLOCK / V2(3),BBLOCK(3072)
     */ CBLOCK / V3(3),CBLOCK(4096)
     */ FLA / FLA
     */ FLB / FLB
     */ FLC / FLC
     */ NAPPOI / NAPPOI
     */ BPOINT / BPOINT
     */ CPOINT / CPOINT
     */ SNUM / SNUM
C
      COMMON
     */ CPLIST / BBC(3) ,CPLIST ( 128)
     */ CAR / B1(4) ,CAR(15767)
     */ CDR / B2(4) ,CDR(15767)
     */ ALMODE / ALMODE
     */ NENTPO / NENTPO
C
      COMMON
     */ R / C1(3) ,R(128)
     */ S / C2(3) ,S(128)
     */ PADRE / C3(3),PADRE(128)
     */ FIRSTS / C4(3),FIRSTS(128)
     */ FIRSTB / C5(3),FIRSTB(128)
     */ LIST / C6(3),LIST(128)
     */ LIB / LIB
     */ CXTX / B1(3),CXTX(128)
     */ CXT / BB1(3),CXT(256)
     */ KEY / BB2(3),KEY(256)    
C
      COMMON
     */ NIL / NIL
     */ BASE / BASE
     */ NEVALV / NEVALV
     */ UNNO / UNNO
     */ NTYPEE / NTYPEE
     */ ACXT / ACXT
     */ AAK / AAK
     */ RADIX / RADIX
     */ RRADIX/ RRADIX
     */ PPDEM / PPDEM
     */ CXTM / CXTM
     */ CXTT / CXTT
     */ NAPPID / NAPPID
     */ T / T
C
C
       DIMENSION
     *FUN(1284),RETP (1284),CP(1284),BLP(1284),SEGNO(1284),ABP(1284),
     *BIND(3072),VAR(3072),BBP(3072),SONBRO(4096),NREENT (4096),
     *VALORE(4096),INF(4096),LISTAR(4096),BLINK(4096)
C
C
       EQUIVALENCE
     *(ABLOCK(1),FUN(1)).
     *(ABLOCK(2),RETP(1)),
     *(ABLOCK(3),CP(1)),
     *(ABLOCK(4),BLP(1)),
     *(ABLOCK(5),SEGNO(1)),
     *(ABLOCK(6),ABP(1)),
     *(BBLOCK(1),BIND(1)),
     *(BBLOCK(2),VAR(1)),
     *(BBLOCK(3),BBP(1)),
     *(CBLOCK(1),SONBRO(1)),
     *(CBLOCK(2),NREENT(1)),
     *(CBLOCK(3),VALORE(1)),
     *(CBLOCK(3),INP(1)),
     *(CBLOCK(4),LISTAR(1)),
     *(CBLOCK(4),BLINK(1))
C
      DATA KEYM/-1/,UNO/1/,TRE/3/,DUE/2/
C
      CALL GETARG
      INDIC = NENTPO-71
      GO TO
     *(72,73,74,75,3,3,78,79,80),INDIC
3     WRITE(6,1004) NENTPO
1004  FORMAT (' MPATTE,NENTPO ERRATO',I10)
      CALL HLT
C     DELOCAZIONE E RITORNO.
76831 IF (ALMODE .NE. 0) GO TO 1
      CALL CPOP
      SONBRO(CPOINT) = MOD(SONBRO(CPOINT),UNNO)
      GO TO 2
1     CPOINT = BLINK (CPOINT)
2     RETURN
11121 CALL ERROF(21)
11122 CALL ERROP(22)
11124 CALL ERROF(24)
11125 CALL ERROF(25)
11136 CALL ERROF(36)
C
C***********    SCT PN    ***********************************
72    RFLAG = 0
      GOTO 9182
      ENTRY SCTPN
      RFLAG = 1
9182  CONTINUE
      UNIT=6
      MTEMP=LISTSC
2000  MASK=9*NTYPEE+BASE
      IF (MTEMP.EQ.0) GOTO 2001
      WRITE(UNIT,2002) MTEMP,BLINK(MTEMP)
2002  FORMAT ('0',2I6)
      TEMP=INF(MTEM P)
      IF(FTYPE(TEMP).NE.REDEFT) GOTO 2003
2004  IF(TEMP.EQ.NIL) GOTO 2005
      CAR(CAR(TEMP))=CAR(CAR(TEMP)) +MASK
      CDR(CAR(TEMP))=CDR(CAR(TEMP)) +MASK
      TEMP=CDR(TEMP)
      GOTO 2004
2005  IF(MASK.LT.O) GOTO 2006
      MASK=-MASK
      TEMP=INF(MTEMP)-31*NTYPEE
      CALL PRINTS(TEMP,UNO)
      CALL OUTBUF
      GOTO 2004
2003  WRITE(UNIT,2007) RRADIX,INF(MTEMP)
2007  FORMAT(' (',I5,'. ',I5,')')
2006  WRITE(UNIT,2007) CAR(NREENT(MTEMP)),CDR(NREENT(HTEMP))
      MTEMP=SONBRO(MTEMP)
      GOTO 2000
2001  CONTINUE
           IF (RFLAG.EQ.0) GOTO 76833
      RETURN
76833 NEVALV=NIL
      GOTO 76831
C
C     ENTLAB(73) /*GETCXT */
C
73    ARG2 = ARGF(2)
      IF(ARG2.NE.NIL) GOTO 95
      CALL RINCA(ACXT,UNO,KEYTEM)
      IF(KEYTEM.LT.0) GOTO 11122
      ARG2 = ACXT
      GO TO 96
95    IF(FTYPE(ARG2).NE.CXTT)    GOTO 11121
      KEYTEM = ARG2
      CALL RINCA(KEYTEM,UNO,KEY1)
      IF (KEY1.LT.O) GOTO 11122
96    ARG1 = ARGF(1)
      IF(ARG1.EQ.NIL) GO TO 97
      IF(FTYPE(ARG1).NE.SNUM.OR.ARG1.LT.BASE) CALL ERROF(33)
      KEYTEM = AAK
      ARG1M = ARG 1-1
      DO 98 I=BASE,ARG1M
      DUMMY = MOD(ARG2,NTYPEE)
      CALL RINCA(DUMMY,UNO,AAK)
      IF(PADRE(AAK).NE.O) GO TO 99
981   AAK = KEYTEM
      NEVALV = NIL
      GOTO 76831
99    KEY2 = PADRE(AAK)
      IF (KEY2.EQ.0) GO TO 981
      IF (CXTX(KEY2).GT.0) GO TO 982
      AAK = KEY2
      GO TO 99
982   ARG2 = CXTX(KEY2)
98    CONTINUE
      AAK = KEYTEM
C
C     RISCXT
C
97    NEVALV = ARG2+CXTM
      GO TO 76831
C
C     AVOP
C
74    ARG1=ARGF(1)
744   CONTINUE
C CONTROLLO ARGOMENTI PER AVOP E YMCA
      IF(ARG1/NTYPEE.NE.CXTT) GOTO 11121
      KEYTEM=ARG1
      CALL RINCA(KEYTEM,UNO,KEY1)
      IF(KEY1.LE.O) GOTO 11122
      ARG2=ARGF(2)
      IF(ARG2.EQ.NIL) GOTO 175
      IF(ARG2/NTYPEE.NE.CXTT) GOTO 11121
      KEYTEM=ARG2
      CALL RINCA(KEYTEM,UNO,KEY2)
      IF(KEY2.LE.O) GOTO 11122
      GOTO 176
175   KEY2=AAK
176   IF(NENTPO.EQ.75) GOTO 755
C BODY AVOP
      NEVALV=NIL
      IF(R(KEY1).GT.R(KEY2)) GOTO 76831
      IF(R(KEY2).LE.S(KEY1)) NEVALV=ARG1
      GOTO 76831
C
C YMCA
C
75    ARG1=ARGF(1)
      IF(ARG1.NE.NIL) GOTO 744
      C YMCA SENZA ARGOMENTI = RADIX
      NEVALV=CXTX(RRADIX)+CXTM
      GOTO 76831
755   CONTINUE
C BODY YMCA CON ARGOMENTI
      IF(R(KEY1).GT.R(KEY2)) GOTO 6600
      IF(R(KEY2).GT.S(KEY1)) GOTO 6600
C R(KEY1)MINORE O = R(KEY2) MINORE O = S(KEY 1)
      NEVALV=CXTX(KEY1)+CXTM
      GOTO 76831
6600  KEY1=PADRE(KEY1)
      GOTO 755
C
C      ENTLAB (78) /* STAMPA GXT-TREE */
C
78    CONTINUE
      RFLAG =0
      GOTO 778
      ENTRY CXTREE
      RFLAG=1
778   I = LIST (LIB)
      J = RADIX
      WRITE(6,1005)
C
C     UNI
C
64    WRITE(6,1006) J,
     * R(J),S(J),PADRE(J),CXTX(J),FIRSTS(J),FIRSTB(J),LIST(J)
      J = LIST(J)
      IF(J.NE.I) GO TO 64
       IF(RFLAG.EO.O) GOTO 76833
       RETURN
1005  FORMAT ( 1X ,'    ORDER        R        S    PADRE    CXTX  FIRSTS',
     *'  FIRSTB    LIST')
1006  FORMAT(1X ,10I8)
C
C     ENTLAB (79) /*SON */
C
79    ARG1 = ARGF(1)
      IF(ARG1.NE.NIL) GO TO 65
      IF(CXTX(AAK).LT.O) GOTO 11122
      KEYTEM = AAK
      GO TO 66
65    IF(PTYPE(ARG1).NE.CXTT)    GOTO 11121
      DUMMY = MOD(ARG1,NTYPEE)
      CALL RINCA(DUMMY,UNO,KEYTEM)
      IF(KBYTEM.LT.O) GOTO 11122
66    NEVALV = NIL
      KEYTEM = FIRSTS(KEYTEM)
C
C     DO WHILE (KEYTEMP.NE.0)
C
678   IF(KBYTEM.EQ.O) GOTO 76831
      NEVALV = CONSP(CXTM+CXTX(KEYTEM),NEVALV)
681   KEYTEM = FIRSTB (KEYTEM)
      GO TO 678
C
C     ENTLAB(80) CONTRACT
C
80    ARG1 = ARGF(1)
      ARG2 = ARGF(2)
      IF(ARG1.EQ.NIL.OR.FTYPE(ARG1).NE.CXTT)
      GOTO 11121
      IF(ARG2.EQ.NIL) GO TO 1200
      IF(FTYPE(ARG2).NE.CXTT)
      GOTO 11121
C
C     J = 2 CONTRACT CON DUE ARGOMENTI
C
      J = 2
      DUMMY = ARG1
      KEYTEM = ARG2
      CALL RINCA(DUMMY,UNO,KEY1)
      IF(KEY1.LT.O) GOTO 11122
      CALL RINCA(KEYTEM,UNO,KEY2)
      IF(KEY2.LT.0) GOTO 11122
C
C     CONTRACT (X Y)
C     VERIFICA DELLA DISCENDENZA DI KEY2 DA KEY1
C
      IF(R(KEY1).GT.R(KEY2).OR.S(KEY1).LT.S(KEY2)) GOTO 11124
C
C     SI CONTROLLA SE AAK (CHIAVE ATTUALE) E' UN SUCCESSORE DI KEY2
C     SE VERO: PUO' ESSERE ESEGUITA LA CONTRACT (X Y)
C     SE FALSO: SI CONTROLLA CHE AAK NON FACCIA PARTE DEL
C     SOTTOALBERO CON RADICE IN KEY1 O SIA UGUALE A KEY1 STESSA.
C
      IF(R(AAK).GE.R(KEY2).AND.S(AAK).LE.S(KEY2)) GOTO 300
      IF(R(AAK).GE.R(KEY1).AND.S(AAK).LE.S(KEY1)) GOTO 11125
      GO TO 300
C
C     J = 1  CONTRACT CON UN SOLO ARGOMENTO
C
1200  DUMMY = ARG1
      CALL RINCA(DUMMY,UNOKEY1)
      IF(KEY1.LT.0) GOTO 11122
C
C               CONTRACT(X)
C     SI CONTROLLA CHE AAK NON FACCIA PARTE DEL SOTTOALBERO CON RADICE
C     IN KEY1 ,O SIA UGUALE A KEY1 STESSA.
C
      IF(R(AAK).GE.R(KEY1).AND.S(AAK).LE.S(KEY1))   GOTO 11125
      J = 1
C
C     O.K. TEST SULLA DISCENDENZA
C     O.K. TEST SULLA VITA FUTURA DELLA CHIAVE ATTUALE
C
300   GO TO (8008,8010), J
C     SI VERIFICA CHE LA RADICE DEL SOTTOALBERO DA CONTRATTARE
C     NON SIA UGUALE ALLA RADICE VIRTUALE.
C
8010  IF(RRADIX.NE.KEY1) GO TO 8008
C     RRADIX = KEY1.
C     SI INTENDE SOSTITUIRE AL SOTTOALBERO RADICATO IN RRADIX IL
C     SOTTOALBERO CON RADICE IN KEY2.
C     SI PONGONO A ZERO I PUNTATORI AL PADRE E AL BROTHER DELLA
C     NUOVA RADICE KEY2
C
      RRADIX = KEY2
      FIRSTB(KEY2) = 0
      PADRE(KEY2) = 0
      GO TO 3000
C
C     SI INIZIA LA RICERCA DI KEY1 PARTENDO DA SUO PADRE.
C
8008  IPP = FIRSTS(PADRE(KEY1))
      IP1 = IPP
8002  IF(CXTX(IPP).EQ.DUMMY) GO TO 8001
      IP1 = IPP
      IPP = FIRSTB(IPP)
      GO TO 8002
C     HO TROVATO KEY1.
C     CONTROLLO SE (IPP = IP1) E' IL PRIMO FIGLIO.
C     SE IPP .NOT EQUAL. IP 1 ALLORA KEY1 NON E' FIGLIO UNICO.
8001  IF(IPP.EQ.IP1) GO TO (8009,8004),J
      GO TO (8007,8005),J
C
C     KEY 1 NON E' IL PRIMO FIGLIO. CONTRACT (X)
8007  FIRSTB(IP1) = FIRSTB(KEY1)
      GO TO 3000
C
C     KEY1 NON E' IL PRIMO FIGLIO. CONTRACT (X Y)
C
8005  FIRSTB(IP1) = KEY2
      GO TO 8006
C
C     KEY 1 E' IL PRIMO FIGLIO. CONTRACT (X Y)
C
8004  FIRSTS(PADRE(KEY1)) = KEY2
8006  FIRSTB(KEY2) = FIRSTB(KEY1)
      PADRE(KEY2) = PADRE(KEY1)
      GO TO 3000
C
C     KEY 1 E' IL PRIMO FIGLIO. CONTRACT (X)
C
8009  FIRSTS(PADRE(KEY1)) = FIRSTB(KEY1)
C
C     SI MARCANO I MONDI NON PIU COLLETTATI ALL' ALBERO DEI CONTESTI
C
3000  I = RADIX
      LIB1 = LIST(LIB)
800   IF(CXTX(I).LE.O) GO TO 444
      GO TO (555,666),J
C
C     CONTRACT(X Y)
C     SI CONTROLLA SE IL MONDO IN ESAME PUO ESSERE UCCISO.
C
666   IF(R(KEY1).LE.R(I).AND.R(I).LT.R(KEY2)) GO TO 777
      IF(S(KEY2).LT.R(I).AND.R(I).LE.S(KEY1)) GO TO 777
      GO TO 444
C
C     EUTANASIA
C     ---------
C     CONTRACT(X) ; CONTRACT (X Y)
C     SI UCCIDE, SENZA DOLORE, UN MONDO
C
777   CALL RINCA(CXTX(I),TRE,KEYM)
      CXTX(I) = -CXTX(I)
      CPLIST (I) = NIL
      GO TO 444
C
C     CONTRACT(X)
C     SI CONTROLLA SE IL MONDO IN ESAME PUO ESSERE UCCISO
C
555   IF(R(I).GE.R(KEY1).AND.S(I).LE.S(KEY1)) GO TO 777
444   I = LIST(I)
      IF(I.NE.LIB1) GO TO 800
      GO TO (448,447),J
C
C     CONTRACT (X Y)
C     UCCISIONE EUGENETICA EFFETTUATA.
C     SI RESTITUISCE COME RISULTATO IL SECONDO ARGOMENTO DELLA CONTRACT
C     SI PONE A ZERO LA VARIABILE NREDMO SOLO SE LA RADICE VIRTUALE
C     NON HA FIGLI (NE ADULTERINI, NE INCESTUOSI O ROBA DEL GENERE.)
C
447   NEVALV = ARGF(2)
      IF(FIRSTS(RRADIX).EQ.O) NREDMO=O
      GOTO 76831
C
C     CONTRACT(X)
C     SI RESTITUISCE IL VALORE DEL PADRE DI KEY1
C     PER NREDMO CI SI COMPORTA COME SOPRA.
C
448   NEVALV = CXTX(PADRE(KEY1))+NTYPEE*CXTT
      IF(FIRSTS (RRADIX) .EQ.O) NREDMO = O
      GOTO 76831
C
C     RECLAIM 1 ENTLAB(98)
      ENTRY GBCCXT
C     UU=1
C     GOTO 778
C
C     TEST SULLO STATO DEI MONDI
C
C     SE TUTTI GODONO OTTIMA SALUTE SI RITORNA CON KGBC = 1.
C     SOLO NEL CASO CHE NON VI SIA PIU LISTA LIBERA PER I CONTEX
C     ALTRIMENTI GARBAGE SULL' ALBERO DEI CONTESTI.
C
980   J = RADIX
609   IF(CXTX(J).LT.O) GO TO 610
      IF(J.EQ.LIB) GO TO 6758
      J = LIST(J)
      GO TO 609
6758  IF(LIST(LIST(LIB)).LT.O) KGBC = 1
      RETURN
C
C        ALMENO UN MONDO E' DEFUNTO. GARBAGE.
C     AZZERAMENTO DEI CXTXS,SONS,BROTHERS,FATHERS DEI MONDI DEFUNTI.
C     AZZERAMENTO LOCAZIONE NELLA TABELLA CHIAVI DI ACCESSO DEL
C     MONDO DEFUNTO. GARBAGE MONDI UCCISI NELLA TABELLA ALBERO DEI
C     CONTESTI
C
C
610   K = 0
      I = RADIX
1300  I1 = LIST(I)
      IF(CXTX(I).GT.0) GO TO 100
      J = LIST(LIB)
      LIST(LIB) = I
      LIST(I) = J
      CXTX(I) = 0
      FIRSTB(I) = 0
      PADRE(I) = 0 
      FIRSTS(I) = 0
105   IF(I.EQ.LIB) GO TO 350
      I = I1
      GO TO 1300
100   IF(K.EQ.O) GO TO 140
      LIST(K) = I
140   K = I
      GO TO 105
C
C     INIZIA DA QUI LA RISTRUTTURAZIONE DELL' ALBERO DEI CONTESTI.
C
350   IF(K.NE.LIB) LIST (K) = LIB
      LIB = K
C
C     DOPO IL COLLETTAMENTO DI TUTTI I MONDI VIVI SI PASSA ALLA
C     FASE DI SISTEMAZIONE DELLA R E DELLA S.
C
401   KEY2 = RRADIX
      PILA(1) = -RRADIX
      R(RRADIX) = 1
      J = 1
      R1 = 1
320   IF(FIRSTS(KEY2).EQ.0) GO TO 321
      KEY2 = FIRSTS(KEY2)
      IF(KEY2.EQ.0) GO TO 321
313   J = J+1
      PILA(J) = KEY2
      IF(FIRSTB(KEY2).EQ.0) GO TO 319
      KEY2 = FIRSTB(KEY2)
      GO TO 313
      319   R1 = R1+1
      R(KEY2) = R1
      PIL(J) = -PILA(J)
      GO TO 320
316   KEY2 = PILA(J)
      GO TO 319
321   IF(PILA(J).GT.0) GO TO 316
      KEY2 = -PILA(J)
      S(KEY2) = R1
      J = J-1
      IF(J.GT.0) GO TO 321
C
C     FINE RIORDINAMENTO DELL' ABERO DEI CONTESTI
C     SI PONE LA RADICE REALE UGUALE A QUELLA VIRTUALE
      RADIX = RRADIX
C ****** RIGENERAZIONE TABELLA PER RINCA *********
      DO  7641 I=1 ,256
      CXT(I) =0
7641  KEY(I) =0
C  * 110 E' IL NOME INTERNO DEL COMMON 'I1'  *
      DO 7642 I=1,I10
      KEY1=LIFE(I)
      KEY2=CXTX(KEY1)
7642  CALL RINCA(KEY2,DUE,KEY1)
C      UU=2
C      GOTO 778
C 7778  OU =0
C      WRITE (6,7721) (CXT(I),KEY(I),I=1,256)
C      WRITE (6,5532) (LIFE(I),I=1,128)
C 5532  FORMAT (1H0,10(1X,I5))
      RETURN
      END
