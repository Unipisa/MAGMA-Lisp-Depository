C     RRADIX = KEY1.
C     SI INTENDE SOSTITUIRE AL SOTTOALBERO RADICATO IN RRADIX IL
C     SOTTOALBERO CON RADICE IN KEY2.
C     SI PONGONO A ZERO I PUNTATORI AL PADRE E AL BROTHER DELLA
C     NUOVA RADICE KEY2
C
      RRADIX = KEY2
      FIRSTB(KEY2) = 0
      PADRE(KEY2) = 0
      GO TO 3000
C
C     SI INIZIA LA RICERCA DI KEY1 PARTENDO DA SUO PADRE.
C
8008  IPP = FIRSTS(PADRE(KEY1))
      IP1 = IPP
8002  IF(CXTX(IPP).EQ.DUMMY) GO TO 8001
      IP1 = IPP
      IPP = FIRSTB(IPP)
      GO TO 8002
C     HO TROVATO KEY1.
C     CONTROLLO SE (IPP = IP1) E' IL PRIMO FIGLIO.
C     SE IPP .NOT EQUAL. IP 1 ALLORA KEY1 NON E' FIGLIO UNICO.
8001  IF(IPP.EQ.IP1) GO TO (8009,8004),J
      GO TO (8007,8005),J
C
C     KEY 1 NON E' IL PRIMO FIGLIO. CONTRACT (X)
8007  FIRSTB(IP1) = FIRSTB(KEY1)
      GO TO 3000
C
C     KEY1 NON E' IL PRIMO FIGLIO. CONTRACT (X Y)
C
8005  FIRSTB(IP1) = KEY2
      GO TO 8006
C
C     KEY 1 E' IL PRIMO FIGLIO. CONTRACT (X Y)
C
8004  FIRSTS(PADRE(KEY1)) = KEY2
8006  FIRSTB(KEY2) = FIRSTB(KEY1)
      PADRE(KEY2) = PADRE(KEY1)
      GO TO 3000
C
C     KEY 1 E' IL PRIMO FIGLIO. CONTRACT (X)
C
8009  FIRSTS(PADRE(KEY1)) = FIRSTB(KEY1)
C
C     SI MARCANO I MONDI NON PIU COLLETTATI ALL' ALBERO DEI CONTESTI
C
3000  I = RADIX
      LIB1 = LIST(LIB)
800   IF(CXTX(I).LE.O) GO TO 444
      GO TO (555,666),J
